<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My BGG Shelf</title>
    <style>
        /* --- CSS Styling --- */
        :root {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --danger-color: #e74c3c;
            --light-color: #ecf0f1;
            --dark-color: #2c3e50;
            --grey-color: #bdc3c7;
            --card-bg: #ffffff;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --border-radius: 5px;
            --box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            --transition-speed: 0.3s;
        }

        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-family);
            line-height: 1.6;
            background-color: var(--light-color);
            color: var(--dark-color);
            padding-bottom: 50px; /* Space for footer */
        }

        .container {
            max-width: 1200px;
            margin: 20px auto;
            padding: 0 15px;
        }

        header {
            background-color: var(--dark-color);
            color: var(--light-color);
            padding: 1rem 0;
            text-align: center;
            margin-bottom: 2rem;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
        }

        h1, h2 {
            margin-bottom: 1rem;
            color: var(--primary-color);
        }

        h1 {
            color: var(--light-color);
        }

        section {
            background-color: var(--card-bg);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
        }

        /* Forms */
        .form-group {
            margin-bottom: 1rem;
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap; /* Wrap elements on smaller screens */
        }

        input[type="text"],
        input[type="number"] {
            flex-grow: 1; /* Take available space */
            padding: 0.75rem;
            border: 1px solid var(--grey-color);
            border-radius: var(--border-radius);
            font-size: 1rem;
            min-width: 150px; /* Ensure inputs don't get too small */
        }

        button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: background-color var(--transition-speed) ease, transform var(--transition-speed) ease;
            background-color: var(--primary-color);
            color: white;
        }

        button:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background-color: var(--secondary-color);
        }
         button.secondary:hover {
             background-color: #27ae60;
         }

        button.danger {
            background-color: var(--danger-color);
        }
         button.danger:hover {
             background-color: #c0392b;
         }

        button.outline {
            background-color: transparent;
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
        }
        button.outline:hover {
            background-color: var(--primary-color);
            color: white;
        }

        /* Game Grid / Cards */
        .game-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-top: 1rem;
        }

        .game-card {
            background-color: var(--light-color);
            border-radius: var(--border-radius);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: transform var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
        }

        .game-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--box-shadow);
        }

        .game-card img {
            width: 100%;
            height: 180px; /* Fixed height */
            object-fit: cover; /* Scale while maintaining aspect ratio */
            display: block;
            background-color: var(--grey-color); /* Placeholder background */
        }

        .game-card-content {
            padding: 1rem;
            flex-grow: 1; /* Takes remaining space */
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* Pushes button to bottom */
        }

        .game-card h3 {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            color: var(--dark-color);
        }

        .game-card p {
            font-size: 0.9rem;
            color: #555;
            margin-bottom: 1rem;
        }

        .game-card button {
            width: 100%;
            font-size: 0.9rem;
            padding: 0.5rem 1rem;
            margin-top: auto; /* Push button to bottom */
        }
        .game-card button.owned {
             background-color: var(--secondary-color);
             cursor: not-allowed;
         }
         .game-card button.owned:hover {
             background-color: var(--secondary-color); /* No hover change */
             transform: none;
         }


        /* Filter Controls */
        #filter-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        #filter-controls label {
             white-space: nowrap; /* Prevent label text wrapping */
        }

        /* Loading / Messages */
        .loading-indicator, .message {
            text-align: center;
            padding: 1rem;
            margin-top: 1rem;
            font-style: italic;
            color: #777;
        }

        /* Footer */
        footer {
            text-align: center;
            margin-top: 2rem;
            padding: 1rem;
            font-size: 0.9em;
            color: #666;
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: var(--grey-color);
        }

        /* Responsiveness */
        @media (max-width: 768px) {
            .game-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 1rem;
            }
            .game-card img {
                height: 150px;
            }
            h1 { font-size: 1.8rem; }
            h2 { font-size: 1.5rem; }
        }

        @media (max-width: 480px) {
            .container { padding: 0 10px; }
            section { padding: 1rem; }
            .form-group { flex-direction: column; }
            input[type="text"], input[type="number"], button { width: 100%; }
            .game-grid {
                grid-template-columns: 1fr 1fr; /* Two columns on small mobile */
                gap: 0.8rem;
            }
             .game-card img {
                height: 120px;
            }
            .game-card h3 { font-size: 1rem; }
            .game-card p { font-size: 0.8rem; }
             #filter-controls { flex-direction: column; align-items: stretch; }
             #filter-controls input, #filter-controls button { width: 100%; }
        }

    </style>
</head>
<body>

    <header>
        <h1>My BGG Shelf</h1>
    </header>

    <div class="container">
        <!-- Search Section -->
        <section id="search-section">
            <h2><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor" style="vertical-align: middle; margin-right: 5px;"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>Search Games on BGG</h2>
            <div class="form-group">
                <input type="text" id="search-input" placeholder="Enter game name...">
                <button id="search-button">Search</button>
            </div>
            <div id="search-loading" class="loading-indicator" style="display: none;">Searching BGG...</div>
            <div id="search-message" class="message" style="display: none;"></div>
        </section>

        <!-- Results Section -->
        <section id="results-section" style="display: none;">
            <h2>Search Results</h2>
            <div id="game-results" class="game-grid">
                <!-- Game cards will be injected here -->
            </div>
        </section>

        <!-- Owned Games Section -->
        <section id="owned-section">
             <h2><svg xmlns="http://www.w3.org/2000/svg" enable-background="new 0 0 24 24" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor" style="vertical-align: middle; margin-right: 5px;"><g><rect fill="none" height="24" width="24"/><path d="M18,2H6C4.9,2,4,2.9,4,4v16c0,1.1,0.9,2,2,2h12c1.1,0,2-0.9,2-2V4C20,2.9,19.1,2,18,2z M6,4h5v8l-2.5-1.5L6,12V4z M18,20H6 V18h12V20z M18,16H6v-2h12V16z M18,12h-5l-1,0.63L11.25,12H18V12z M18,9h-5V7h5V9z M18,6h-5V4h5V6z"/></g></svg>My Owned Games</h2>
            <div id="filter-controls">
                <label for="player-filter">Filter by # Players:</label>
                <input type="number" id="player-filter" min="1" placeholder="e.g., 4">
                <button id="filter-button" class="secondary">Filter</button>
                <button id="show-all-button" class="outline">Show All</button>
            </div>
             <div id="owned-loading" class="loading-indicator" style="display: none;">Loading owned games...</div>
            <div id="owned-games" class="game-grid">
                <!-- Owned game cards will be injected here -->
            </div>
             <div id="owned-message" class="message" style="display: none;"></div>
        </section>
    </div>

    <footer>
        Data sourced from BoardGameGeek. Please respect their API usage guidelines.
    </footer>

    <!-- Firebase SDK -->
    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getFirestore, collection, getDocs, setDoc, doc, deleteDoc, query, where } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyD4Ng_czJgkmlhin-evqEohQkRl4Imii-4",
            authDomain: "gameshelf-iejuq.firebaseapp.com",
            projectId: "gameshelf-iejuq",
            storageBucket: "gameshelf-iejuq.firebasestorage.app",
            messagingSenderId: "344168951806",
            appId: "1:344168951806:web:33979d550dafa6ffd0daaf"
        };

        // Check if config is placeholder
        const isConfigPlaceholder = !firebaseConfig.apiKey || firebaseConfig.apiKey.startsWith("AIzaSy..."); // A basic check

        let db;
        let ownedGamesCache = []; // Local cache for owned games
        const ownedGameIds = new Set(); // Fast lookup for owned status

        // Initialize Firebase
        try {
             if (isConfigPlaceholder) {
                 console.warn("Firebase config is missing or using placeholder values. Firestore features will be disabled.");
                 displayMessage('owned-message', "Please configure Firebase in the HTML file to save/load owned games.", true);
             } else {
                 const app = initializeApp(firebaseConfig);
                 db = getFirestore(app, "default");
                 console.log("Firebase Initialized");
                 fetchOwnedGames(); // Load owned games on startup
             }
        } catch (error) {
            console.error("Firebase Initialization Error:", error);
            displayMessage('owned-message', `Firebase initialization failed: ${error.message}`, true);
        }


        // --- DOM Elements ---
        const searchInput = document.getElementById('search-input');
        const searchButton = document.getElementById('search-button');
        const searchLoading = document.getElementById('search-loading');
        const searchMessage = document.getElementById('search-message');
        const resultsSection = document.getElementById('results-section');
        const gameResultsContainer = document.getElementById('game-results');

        const ownedLoading = document.getElementById('owned-loading');
        const ownedMessage = document.getElementById('owned-message');
        const ownedGamesContainer = document.getElementById('owned-games');
        const playerFilterInput = document.getElementById('player-filter');
        const filterButton = document.getElementById('filter-button');
        const showAllButton = document.getElementById('show-all-button');

        // --- BGG API Functions ---
        const BGG_API_SEARCH_URL = 'https://boardgamegeek.com/xmlapi2/search';
        const BGG_API_THING_URL = 'https://boardgamegeek.com/xmlapi2/thing';

        async function searchBgg(query) {
            showLoading('search-loading', true);
            displayMessage('search-message', '', false); // Clear previous messages
            resultsSection.style.display = 'none'; // Hide results section initially
            gameResultsContainer.innerHTML = ''; // Clear previous results

            if (!query.trim()) {
                 displayMessage('search-message', 'Please enter a game name.', true);
                 showLoading('search-loading', false);
                 return;
            }

            const url = `${BGG_API_SEARCH_URL}?type=boardgame,boardgameexpansion&query=${encodeURIComponent(query)}`;

            try {
                const response = await fetchWithRetry(url);
                if (!response.ok) throw new Error(`BGG Search API Error: ${response.statusText}`);

                const xmlText = await response.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, "application/xml");

                const items = xmlDoc.querySelectorAll("item");
                if (!items || items.length === 0) {
                    displayMessage('search-message', 'No games found for that query.', true);
                    resultsSection.style.display = 'block'; // Show section even if empty
                    showLoading('search-loading', false);
                    return;
                }

                const gameIds = Array.from(items).slice(0, 20).map(item => item.getAttribute('id')).filter(id => id); // Limit results, filter nulls

                if (gameIds.length > 0) {
                    await fetchGameDetails(gameIds);
                } else {
                     displayMessage('search-message', 'No valid game IDs found in search results.', true);
                }


            } catch (error) {
                console.error("Error searching BGG:", error);
                displayMessage('search-message', `Error searching BGG: ${error.message}`, true);
            } finally {
                showLoading('search-loading', false);
            }
        }

        async function fetchGameDetails(ids) {
             showLoading('search-loading', true); // Use search loading as details are part of search flow
             const url = `${BGG_API_THING_URL}?id=${ids.join(',')}&stats=1`; // stats=1 includes ratings which can have player counts

             try {
                 const response = await fetchWithRetry(url);
                 if (!response.ok) throw new Error(`BGG Thing API Error: ${response.statusText}`);

                 const xmlText = await response.text();
                 const parser = new DOMParser();
                 const xmlDoc = parser.parseFromString(xmlText, "application/xml");

                 const items = xmlDoc.querySelectorAll("item[type='boardgame'], item[type='boardgameexpansion']");
                 const gamesData = Array.from(items).map(item => parseGameData(item)).filter(game => game); // Filter out potential parsing errors

                 displayResults(gamesData);

             } catch (error) {
                 console.error("Error fetching game details:", error);
                 displayMessage('search-message', `Error fetching game details: ${error.message}`, true);
             } finally {
                  showLoading('search-loading', false);
                  resultsSection.style.display = 'block'; // Show results section
             }
        }

        function parseGameData(itemElement) {
             try {
                const id = itemElement.getAttribute('id');
                const nameElement = itemElement.querySelector("name[type='primary']");
                const name = nameElement ? nameElement.getAttribute('value') : 'N/A';
                const image = itemElement.querySelector("image")?.textContent || '';
                const thumbnail = itemElement.querySelector("thumbnail")?.textContent || image; // Fallback to image if no thumbnail
                const minPlayers = itemElement.querySelector("minplayers")?.getAttribute('value') || '?';
                const maxPlayers = itemElement.querySelector("maxplayers")?.getAttribute('value') || '?';

                return {
                    id,
                    name,
                    image: thumbnail || image, // Prefer thumbnail for cards
                    minPlayers,
                    maxPlayers,
                };
             } catch (e) {
                 console.error("Error parsing game data for item:", itemElement, e);
                 return null; // Return null if parsing fails for an item
             }
        }

         // BGG API can be flaky, add retry logic with delay
        async function fetchWithRetry(url, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url);
                    if (response.status === 202 || response.status === 200) { // 202 Accepted means BGG queued it, 200 OK
                         if (response.status === 202) {
                            console.log(`BGG API returned 202 (Accepted), retrying after ${delay}ms...`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            continue; // Retry the request
                         }
                         return response; // Got 200 OK
                    }
                    // If other error, throw to be caught below
                    throw new Error(`Non-success status code: ${response.status}`);
                } catch (error) {
                    console.warn(`Fetch attempt ${i + 1} failed for ${url}:`, error);
                    if (i < retries - 1) {
                        await new Promise(resolve => setTimeout(resolve, delay * (i + 1))); // Exponential backoff (simple)
                    } else {
                        throw error; // Rethrow after final retry
                    }
                }
            }
             throw new Error(`Fetch failed after ${retries} retries for ${url}`); // Should not be reached ideally
        }


        // --- Display Functions ---
        function displayResults(games) {
            gameResultsContainer.innerHTML = ''; // Clear previous
            if (!games || games.length === 0) {
                displayMessage('search-message', 'No game details could be fetched or parsed.', true);
                return;
            }
            displayMessage('search-message', '', false); // Clear any previous messages

            games.forEach(game => {
                const card = createGameCard(game, 'search');
                gameResultsContainer.appendChild(card);
            });
        }

        function displayOwnedGames(games) {
            ownedGamesContainer.innerHTML = ''; // Clear previous
             if (!games || games.length === 0) {
                 const currentFilter = playerFilterInput.value;
                 if (currentFilter) {
                      displayMessage('owned-message', `No owned games found for ${currentFilter} players.`, false);
                 } else if (!isConfigPlaceholder){ // Only show "No games owned" if Firebase is configured
                      displayMessage('owned-message', 'You haven\'t marked any games as owned yet.', false);
                 }
                 showLoading('owned-loading', false);
                 return;
             }
             displayMessage('owned-message', '', false); // Clear any message

            games.sort((a, b) => a.name.localeCompare(b.name)); // Sort alphabetically
            games.forEach(game => {
                const card = createGameCard(game, 'owned');
                ownedGamesContainer.appendChild(card);
            });
             showLoading('owned-loading', false);
        }

        function createGameCard(game, context) {
            const card = document.createElement('div');
            card.className = 'game-card';
            card.dataset.gameId = game.id;

             const players = (game.minPlayers === '?' || game.maxPlayers === '?') ? 'N/A'
                            : (game.minPlayers === game.maxPlayers) ? `👥 ${game.minPlayers}`
                            : `👥 ${game.minPlayers}-${game.maxPlayers}`;

            card.innerHTML = `
                <img src="${game.image || 'placeholder.png'}" alt="${game.name}" loading="lazy" onerror="this.onerror=null;this.src='data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 50 50\'%3E%3Crect width=\'50\' height=\'50\' fill=\'%23ccc\'/%3E%3Ctext x=\'50%\' y=\'50%\' dy=\'.3em\' text-anchor=\'middle\' fill=\'%23555\' font-size=\'10\'%3ENo Image%3C/text%3E%3C/svg%3E';">
                <div class="game-card-content">
                    <div> <!-- Wrapper for text content -->
                        <h3>${game.name}</h3>
                        <p>Players: ${players}</p>
                    </div>
                    <button class="ownership-button" data-game-id="${game.id}"></button>
                </div>
            `;

            // Configure button based on context and ownership status
            const button = card.querySelector('.ownership-button');
             const isOwned = ownedGameIds.has(game.id);

             if (context === 'search') {
                 if (isOwned) {
                     button.textContent = 'Owned ✔️';
                     button.classList.add('owned');
                     button.disabled = true;
                 } else {
                     button.textContent = 'Mark as Owned';
                     button.classList.add('secondary'); // Green button for adding
                     button.onclick = () => addGameToOwned(game, button);
                 }
             } else { // context === 'owned'
                 button.textContent = 'Remove';
                 button.classList.add('danger');
                 button.onclick = () => removeGameFromOwned(game.id, card);
             }

            return card;
        }

        function showLoading(elementId, show) {
            const element = document.getElementById(elementId);
            if (element) {
                element.style.display = show ? 'block' : 'none';
            }
        }

        function displayMessage(elementId, message, isError = false) {
             const element = document.getElementById(elementId);
             if (element) {
                element.textContent = message;
                element.style.display = message ? 'block' : 'none';
                element.style.color = isError ? 'var(--danger-color)' : '#777';
             }
        }


        // --- Firestore Functions ---
        async function addGameToOwned(game, button) {
             if (!db) {
                 alert("Firestore is not initialized. Cannot save game. Please check Firebase configuration.");
                 console.error("Attempted to add game, but Firestore is not initialized.");
                 return;
             }
            button.disabled = true; // Prevent double clicks
             button.textContent = 'Saving...';

            try {
                // Use BGG ID as the document ID for easy lookup and removal
                const gameRef = doc(db, "ownedGames", game.id);
                await setDoc(gameRef, {
                    name: game.name,
                    image: game.image,
                    minPlayers: game.minPlayers,
                    maxPlayers: game.maxPlayers,
                    addedAt: new Date() // Optional: timestamp
                });

                console.log("Game added to Firestore:", game.id);
                 ownedGameIds.add(game.id); // Update local set
                 ownedGamesCache.push({ ...game, id: game.id }); // Add to local cache (make sure id is string)

                 button.textContent = 'Owned ✔️';
                 button.classList.remove('secondary');
                 button.classList.add('owned');
                 // No need to disable, already done and state change indicates success

                // Refresh owned games list if it's visible
                displayOwnedGames(filterOwnedGamesByPlayerCount(ownedGamesCache, playerFilterInput.value));


            } catch (error) {
                console.error("Error adding game to Firestore:", error);
                alert(`Error saving game: ${error.message}`);
                 button.textContent = 'Mark as Owned'; // Revert button text
                 button.disabled = false; // Re-enable button on error
            }
        }

        async function removeGameFromOwned(gameId, cardElement) {
            if (!db) {
                alert("Firestore is not initialized. Cannot remove game. Please check Firebase configuration.");
                console.error("Attempted to remove game, but Firestore is not initialized.");
                return;
            }

             const confirmRemove = confirm("Are you sure you want to remove this game from your owned list?");
             if (!confirmRemove) return;

             // Optionally disable button while removing
             const button = cardElement.querySelector('.ownership-button');
             if (button) button.disabled = true;


            try {
                const gameRef = doc(db, "ownedGames", gameId);
                await deleteDoc(gameRef);

                console.log("Game removed from Firestore:", gameId);
                ownedGameIds.delete(gameId); // Update local set
                ownedGamesCache = ownedGamesCache.filter(game => game.id !== gameId); // Update local cache

                cardElement.remove(); // Remove card from the UI
                 // Update search results if this game is present there
                 const searchCard = gameResultsContainer.querySelector(`.game-card[data-game-id="${gameId}"]`);
                 if(searchCard) {
                    const searchButton = searchCard.querySelector('.ownership-button');
                    searchButton.textContent = 'Mark as Owned';
                    searchButton.classList.remove('owned');
                    searchButton.classList.add('secondary');
                    searchButton.disabled = false;
                    // Re-attach click listener if needed, or recreate the button
                     const gameData = ownedGamesCache.find(g => g.id === gameId); // Need original data if recreating listener fully
                    if (gameData) { // This should not happen here as we removed it
                        // searchButton.onclick = () => addGameToOwned(gameData, searchButton);
                    } else {
                         // We might need to fetch the game data again to re-enable add button correctly,
                         // or simplify by just enabling the button without the full game object context if necessary.
                         // For simplicity, just re-enable the button appearance. It won't have the add function attached correctly without game data.
                         // A better approach might be to re-run the displayResults logic for the current search.
                         // Quick fix: Just make it look available
                         searchButton.disabled = false;
                    }
                 }

                 // If owned games list becomes empty, show message
                if (ownedGamesContainer.children.length === 0) {
                     displayOwnedGames([]); // Trigger empty message display
                }


            } catch (error) {
                console.error("Error removing game from Firestore:", error);
                alert(`Error removing game: ${error.message}`);
                 if (button) button.disabled = false; // Re-enable button on error
            }
        }

        async function fetchOwnedGames() {
            if (!db) {
                console.log("Firestore not initialized, skipping fetchOwnedGames.");
                showLoading('owned-loading', false);
                return;
            }
             showLoading('owned-loading', true);
             displayMessage('owned-message', '', false);

            try {
                const gamesCol = collection(db, "ownedGames");
                const gameSnapshot = await getDocs(gamesCol);

                ownedGamesCache = []; // Clear cache before fetching
                ownedGameIds.clear(); // Clear set

                gameSnapshot.forEach((doc) => {
                    ownedGamesCache.push({ id: doc.id, ...doc.data() });
                    ownedGameIds.add(doc.id); // Populate the set for quick lookups
                });

                console.log("Fetched owned games:", ownedGamesCache.length);
                 displayOwnedGames(ownedGamesCache); // Display all initially

            } catch (error) {
                console.error("Error fetching owned games:", error);
                displayMessage('owned-message', `Error loading owned games: ${error.message}`, true);
                 showLoading('owned-loading', false);
            }
             // No finally for loading false here, displayOwnedGames handles it
        }

        // --- Filtering Logic ---
        function filterOwnedGamesByPlayerCount(games, playerCountStr) {
            if (!playerCountStr) {
                 return games; // No filter applied
            }
            const playerCount = parseInt(playerCountStr, 10);
            if (isNaN(playerCount) || playerCount <= 0) {
                 return games; // Invalid filter value
            }

            return games.filter(game => {
                 const min = parseInt(game.minPlayers, 10);
                 const max = parseInt(game.maxPlayers, 10);
                 // Handle cases where min/max might not be numbers (though they should be from BGG)
                 if (isNaN(min) || isNaN(max)) {
                    return false; // Exclude games with invalid player counts for filtering
                 }
                 return playerCount >= min && playerCount <= max;
            });
        }

        // --- Event Listeners ---
        searchButton.addEventListener('click', () => searchBgg(searchInput.value));
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                searchBgg(searchInput.value);
            }
        });

        filterButton.addEventListener('click', () => {
            const filteredGames = filterOwnedGamesByPlayerCount(ownedGamesCache, playerFilterInput.value);
            displayOwnedGames(filteredGames);
        });

        playerFilterInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                 const filteredGames = filterOwnedGamesByPlayerCount(ownedGamesCache, playerFilterInput.value);
                 displayOwnedGames(filteredGames);
            }
        });

        showAllButton.addEventListener('click', () => {
            playerFilterInput.value = ''; // Clear filter input
            displayOwnedGames(ownedGamesCache); // Display all cached games
        });

        // --- Initial Load ---
         // fetchOwnedGames() is called after Firebase initialization check
        // Ensure DOM is ready (though script is at the end, module type helps)
         // We already called fetchOwnedGames if firebase is configured.
         if (isConfigPlaceholder) {
             showLoading('owned-loading', false); // Hide loading if firebase is not setup
         }

    </script>
</body>
</html>